## 목차
1. [동시성 프로그래밍이란](#1-동시성-프로그래밍이란)
2. [동시성 프로그래밍이 필요한 이유](#2-동시성-프로그래밍이-필요한-이유)
3. [안전한 동시성 프로그래밍 규칙](#3-안전한-동시성-프로그래밍-규칙)
4. [동시성 테스트 방법](#4-동시성-테스트-방법)
5. [오픈소스 속 동시성 처리](#5-오픈소스-속-동시성-처리)

## 1. 동시성 프로그래밍이란

### 동시성 프로그래밍

* **어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식**
* 외부 서비스의 응답을 기다리면서 아무일도 하지 않으면 CPU 사이클이 낭비된다

### 동시성 프로그래밍 이해하기

![image](https://user-images.githubusercontent.com/110509654/229284063-277f132e-989a-4562-bc60-53da346d5ee3.png)

### 동시성이 구현되지 않은 경우

![image](https://user-images.githubusercontent.com/110509654/229284157-6c38d45f-57ca-41a2-8886-5b49d430badb.png)

### 병렬성을 구현한 경우

![image](https://user-images.githubusercontent.com/110509654/229284266-39d8ab7c-dc82-4c74-8d4d-dba831bbb378.png)

### 동시성을 구현한 경우

![image](https://user-images.githubusercontent.com/110509654/229284346-6b45ab2e-d224-4b95-9641-8c63a2186011.png)

### 동시성과 병렬성이 구현된 경우

![image](https://user-images.githubusercontent.com/110509654/229284363-af38dac4-d13c-4119-bac9-fc1c726cfb32.png)

=> **클라이언트가 아닌 어플리케이션 관점에서 봐야 한다.**
* 내 어플리케이션의 효율성을 높이고 더불어 내 어플리케이션이 동작하는 머신의 환경이 효율적으로 돌아가도록 메모리 누수나 자원이 낭비되지 않도록 한다.

## 2. 동시성 프로그래밍이 필요한 이유

### ○ 동시성 프로그래밍의 미신과 오해 (1)

동시성은 항상 성능을 높여준다 (X)

**동시성은 때로 성능을 높여준다 (O)**

* 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
* 예시 : 웹 브라우저에서 여러 가지 이미지 리소스들을 불러와 다운로드 하는 경우
* 예시 상황 :Servlet

**Java Servlet 동시성 구현**

![image](https://user-images.githubusercontent.com/110509654/229284509-cc7afbeb-eafe-49be-afa0-1a62007de7de.png)

* 요청이 들어오면 Thread Pool에 있는 Thread가 서블릿의 service() 메서드를 호출한다.
* service의 doGet(), doPost()에서 요청에 대한 처리를 하도록 구현한다.

![image](https://user-images.githubusercontent.com/110509654/229284537-89f39605-6556-442f-96ec-513651611287.png)


### ○ 동시성 프로그래밍의 미신과 오해 (2)

동시성을 구현해도 설계는 변하지 않는다 (X)

**동시성을 구현하면 설계를 바꿔야 한다 (O)**

* 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
* '무엇'과 '언제'를 분리하면 시스템의 구조가 크게 달라진다.

### ○ 동시성 프로그래밍의 미신과 오해 (3)

Web이나 EJB와 같은 컨테이너를 사용한다면 동시성을 이해할 필요가 없다 (X)

**컨테이너를 사용해도 동시성을 이해해야 한다 (O)**

* 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다.
* 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야 한다.


## 3. 안전한 동시성 프로그래밍 규칙

### 단일 책임 원칙(SRP) 설계

**동시성 관련 코드는 다른 코드와 분리하라**

* 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
* 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
* 잘못 구현한 동시성 코드는 다양한 방식으로 실패한다. 주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로도 충분히 어렵다.


### 자료 범위를 제한하라

**공유 자료를 최대한 줄여라**

* 동시 수정 문제를 피하기 위해 객체를 사용하는 코드내 임계영역을 synchronized 키워드로 보호하라.
* 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하는 수고가 필요하기에 임계 영역의 수를 최소화 해야 한다.


### 자료 사본을 사용하라

**공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다**

* 객체를 복사해 읽기 전용으로 사용한다.
* 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다.
* 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.


### Thread는 가능한 독립적으로 구현하라

**다른 스레드와 자료를 공유하지 않는다**

* 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다.
* 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다.
* 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.


### 라이브러리를 이해하라

**java.util.concurrent 패키지를 익혀라**

![image](https://user-images.githubusercontent.com/110509654/229284830-2b88641a-5967-442e-82fa-2611a810b44f.png)

* Thread Safe한 컬렉션을 사용한다. ConcurrentHashMap, AtomicLong
* 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
* 가능하다면 Thread가 Blocking되지 않는 방법을 사용한다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

**공유 객체 하나에는 메서드 하나만 사용하라**

* 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
* 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트에서는 이 메서드를 호출하기만 하면 된다.
* 연결(Adapter) 서버 - 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.

### 문제 상황: 공유 자원 접근

![image](https://user-images.githubusercontent.com/110509654/229284942-ace469ce-3ee9-407e-bd44-28a6bf776f41.png)

### Client Based Lock

![image](https://user-images.githubusercontent.com/110509654/229284954-b38f6dbf-760a-4a01-ae76-8dd29a6fd8a7.png)

### Server Based Lock

![image](https://user-images.githubusercontent.com/110509654/229284972-e96f8f5c-0fd5-4f36-81b1-137631f64510.png)

### Adapter Based Lock

![image](https://user-images.githubusercontent.com/110509654/229285008-b725ac5f-e1d3-4ca6-a07c-1e16466ce524.png)


## 4. 동시성 테스트 방법

### 동시성 코드를 테스트해야 한다

**테스트를 했다고 동시성 코드가 100% 올바르다고 증명하기는 불가능하다. 하지만 충분한 테스트는 위험을 낮춰준다.**

* 문제를 노출하는 테스트 케이스를 작성하라
* 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라
* 테스트가 실패하면 원인을 추적하라
* 다시 돌렸더니 통과한다는 이유로 그냥 넘어가면 절대로 안 된다

### 코드에 보조 코드를 넣어 돌려라

**드물게 발생하는 오류를 자주 발생시키도록 보조 코드를 추가한다**

* 코드에 wait(), sleep(), yield(), priority() 함수를 추가해 직접 구현한다.
* 보조코드를 넣어주는 도구를 사용해 테스트한다.
  * 다양한 위치에 ThreadJigglePoint.jiggle()을 추가해 무작위로 sleep(), yield()가 호출되도록 한다.
* 테스트 환경에서 보조코드를 돌려본다.

### 동시성 코드를 실제 환경이나 테스트 환경에서 돌려본다

**다양한 요청과 상황에 동시성 코드가 정상적으로 동작하는지 확인한다**

* 배포하기 전에 테스트 환경에서 충분히 오랜시간 검증한다.
* 동시성 코드를 배포한 후에 모니터링을 통해 문제가 발생하는지 확인한다.


## 5. 오픈 소스 속 동시성 처리

### Elastic Search - LockingAtomicCounter

![image](https://user-images.githubusercontent.com/110509654/229285157-bb876554-1fa9-44ac-a7a2-bf507de799c9.png)

![image](https://user-images.githubusercontent.com/110509654/229285168-dc873778-aec1-4054-be56-0eef8d2cd7cf.png)

![image](https://user-images.githubusercontent.com/110509654/229285176-989844d7-6444-4faf-8b47-4776abad8db9.png)

![image](https://user-images.githubusercontent.com/110509654/229285186-66c6acfe-6226-4b50-b7ef-a1cbdd03e7d8.png)

![image](https://user-images.githubusercontent.com/110509654/229285195-4cb8a71f-e3d8-47ee-b6a8-b72f21aee0ef.png)

![image](https://user-images.githubusercontent.com/110509654/229285207-01715fc1-5e07-4fff-b912-c5bf1fd839b2.png)











